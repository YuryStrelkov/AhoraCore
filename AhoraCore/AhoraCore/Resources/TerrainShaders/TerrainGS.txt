#version 430

layout(triangles) in;

#include CameraDefinition; ///10

#include TerrainMaterialData; //47

#include TerrainSettings; //10

// layout( line_strip, max_vertices = 4 )out;
layout( triangle_strip, max_vertices = 3 )out;


out vec2 mapCoord_FS;

out vec3 position_FS;

out vec3 tangent_FS;

////////////////

in vec2 mapCoord_GS[];

uniform sampler2D normalMap;
 
uniform vec3 cameraPosition;
  


  
vec3 calcTangent()
{

vec3 v0=gl_in[0].gl_Position.xyz;
vec3 v1=gl_in[1].gl_Position.xyz;
vec3 v2=gl_in[2].gl_Position.xyz;

vec3 e1 = v1-v0;

vec3 e2 = v2-v0;

vec2 uv0 = mapCoord_GS[0];
vec2 uv1 = mapCoord_GS[1];
vec2 uv2 = mapCoord_GS[2];

vec2 deltaUV1 =uv1-uv0;

vec2 deltaUV2 =uv2-uv0;

float r=1.0/(deltaUV1.x*deltaUV2.y-deltaUV1.y*deltaUV2.x);

return normalize((e1*deltaUV2.y - e2*deltaUV1.y)*r);

}  
  
  
  
void main()
{
	vec4 pos;
	vec3 tangent;

	vec3 displacement[3];  
	
	displacement[0]=vec3(0,0,0);
	displacement[1]=vec3(0,0,0);
	displacement[2]=vec3(0,0,0);
	
	float dist = (distance(gl_in[0].gl_Position.xyz,cameraPosition)+
			      distance(gl_in[1].gl_Position.xyz,cameraPosition)+
				  distance(gl_in[2].gl_Position.xyz,cameraPosition))/3;
	
	mat4   vpm = projectionMatrix*viewMatrix;
	
	if(dist<TBNrange)
	{
	    tangent = calcTangent();
		for(int k=0;k<gl_in.length;k++)
		{
		displacement[k]=vec3(0,1,0);
		
		float height = gl_in[k].gl_Position.y;
		
		vec3 normal = normalize(texture(normalMap,mapCoord_GS[k]).rgb);
		
		float [3] materialAlpha  = float [](0,0,0);
		if(normal.y>0.5)
		{
			materialAlpha[1]=1;
		}
		else
		{
			materialAlpha[0]=1;
		}
	
		float scale;
		
     	for(int i=0;i < 2;i++)
			{
			scale += texture(materials[i].heightMap,mapCoord_GS[k]*(settings[i].channels[3].multRGBA).y).r
			         *(settings[i].channels[3].multRGBA).x*materialAlpha[i];
			}
		
		float attenuation = clamp(-distance(gl_in[k].gl_Position.xyz,cameraPosition)/(TBNrange-50)+1,0.0,1.0);
	    
		scale*=attenuation;
		
		displacement[k]*=scale;
		}
	}
	
	for (int i=0;i<gl_in.length();i++)
	{
		pos = gl_in[i].gl_Position + vec4(displacement[i],0);
		
		gl_Position = vpm *pos;
		
		mapCoord_FS = mapCoord_GS[i];
		
		position_FS = pos.xyz;
		
		tangent_FS = tangent;
		
		EmitVertex();
	}
  	
    /*pos = gl_in[0].gl_Position;
	
	gl_Position=vpm *pos;
	
	mapCoord_FS=mapCoord_GS[0];
	
	EmitVertex();   
	
	EndPrimitive();*/
	
}