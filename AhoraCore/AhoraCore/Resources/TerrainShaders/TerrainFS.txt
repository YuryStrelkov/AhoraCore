#version 430

layout(location = 0) out vec4 outColor;

#include TerrainMaterialData;

#include TerrainSettings;

in vec2 mapCoord_FS;

in vec3 position_FS;

in vec3 tangent_FS;

uniform sampler2D normalMap;

uniform sampler2D heightMap;

uniform vec3 cameraPosition;

const vec3 direction = vec3(0.333,0.333,0.333);

const float intensity = 1.2;

float diffuse(vec3 dir, vec3 n, float i)
{
	return max(0.04, dot(n,dir) * i);
}

void main()
{
	float dist = length(cameraPosition - position_FS);

	float height = position_FS.y;

	vec3 normal = texture(normalMap,mapCoord_FS).xyz;
	
    vec3 color0 = texture(materials[0].diffuseMap, mapCoord_FS*settings[0].scaling.x).rgb;

	vec3 color1 = texture(materials[1].diffuseMap, mapCoord_FS*settings[1].scaling.x).rgb;

	float [2] materialAlpha = float[](0,0);
	
	if(normal.y>0.5)
		{
			materialAlpha[1] = 1;
		}
		else
		{
			materialAlpha[0] = 1;
		}
	
	if(dist < TBNrange - 50)
	{
		float attenuation =clamp(-dist/(TBNrange-50)+1,0.0,1.0);
	
		vec3 biTangent = normalize(cross(tangent_FS,normal));
	
    	mat3 TBN =mat3(biTangent,normal,tangent_FS);
		
		vec3 bumpNormal=vec3(0,0,0);
		
		for (int i=0;i<2;i++)
		{
		bumpNormal += ((2*texture(materials[i].normalMap, mapCoord_FS *settings[i].scaling.x).rgb - 1)*materialAlpha[i]) ;
		}		
		bumpNormal=normalize(bumpNormal);
		
		bumpNormal.xz *= attenuation;
		
		normal = normalize(TBN*bumpNormal);
	}
	
	vec3 fragmentColor =  color0*materialAlpha[0]+color1*materialAlpha[1];
	
	float diffuse = diffuse(direction, normal, intensity);

	fragmentColor *= diffuse;
	
	outColor = vec4(fragmentColor,1.0);

}